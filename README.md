# RogueRPG

### 介绍
这是一个使用Hsenl框架实现的demo

### 框架简介
+ Hsenl框架是一款高性能的框架, 0GC, 由于核心底层使用了Bitlist, 所以组件的判存, 获取, 非常快, 且支持多态. 有丰富的API, 满足需求.
+ 框架不依赖于unity, 即便脱离unity, 核心功能以及大多数功能依然可以正常使用, 方便在服务端上使用框架. (这里说的大部分功能能用, 是指物理系统和网格导航是使用的unity的, 无法单独在服务器使用, 但接入第三方也方便, 后续写完联网部分再接这些第三方库)
+ 框架和用户代码分离, 方便更新框架
+ 系统事件执顺序是根据unity的规则来的, 记住一套规则就行了, 不需要再记一套
+ 工具丰富满足日常开发需求
+ 框架处于开发中, 还有些必要的模块正在开发中, 但如果是只做单机的话, 可以用了. 如果说作为一个成熟框架来说, 许多细节还未完善, 比如文档, 安装, 教程, 还有一些操作应该设计的更简单易用一些, 都需要整理完善, 慢慢来吧.
+ 目标: 让Hsenl成为一款高速、成熟、安全、强大、易用、灵活的框架

### 特色模块

> 特色模块不是指其本身有多复杂, 多必不可少, 而是框架独有的, 且比较突出的模块, 我觉的对项目有较大的帮助的, 比如第一个组合器模块对于项目维护带来的好处, 可远比一个两个的好用的局部模块要大的多.
>
> 特色模块是选择该框架的主要理由, 不然都差不多, 选谁不是选呢

##### 组合器系统(Combin)(强烈推荐)

###### 作用

完全解耦、代码复用、避免接口、不惧频繁的交互逻辑的修改

###### 使用

假如两个组件需要交互, 我们可以定义一个组合器, 当两个组件满足条件, 比如出现在同一个实体上时, 或父子实体上时, 就会触发组合, 然后我们把交互逻辑写在组合器中(主要以委托的形式交互), 当任意一个组件离开, 或者父子关系被改变时, 自动断开组合, 实现交互逻辑的热插拔, 同时自动检测委托是否正确移除, 防止内存泄露. 高度优化匹配逻辑, 组合与解组合速度非常快, 也支持自定义组合条件. 

###### 意义 

传统对于组件交互, 为了解耦, 我们会把功能写的足够模块化, 而越模块化, 就越避免不掉要与其他组件交互, 这时, 你可能会选择拿到那个组件, 然后写交互逻辑, 然后运用各种设计模式, 让交互符合<<迪米特法则>>, 假如需要和多个组件交互, 那就得使用接口来解决, 如果没规范好接口, 那又是接口大锅烩, 假如我们需要修改交互呢, 注释原先的逻辑重写呗, 如果改动较大呢, 那难免会把类注释的像个花猫一样, 删吧, 都是好好的代码, 辛苦写的不舍得, 不删吧, 又没地方放, 单独拷贝出来吧, 你又不能保证逻辑都集中在一块的, 时间一长, 可能放回去你都忘了往哪摆了. 又假如, 这个交互整个都不需要了, 你那些接口是删还是不删, 继承的类你也得去改吧, 然后策划说, 还是用回最初那套吧, 你麻不麻.

最后你得到了什么? 

1、写在组件里的一堆其他组件的引用与交互代码, 污染了你组件的独立性

2、你的组件有可能继承了一堆接口

3、组件里有可能有现存的和注释的乱七八糟的代码

4、面对策划来回的修改, 消磨你的意志

有人会说, 现在策划不会这么干了. 你管他呢, 直接提早解决, 防患于未然他不香吗. 

> 顺便说: 对于组件来说, 最好就放弃使用继承, 也不要使用接口.

现在使用组合器后, 我们把交互逻辑单独抽离出来, 单独管理, 用则有, 不用则无, 废弃的代码可以写一份新的交互逻辑覆盖掉原本的交互逻辑. 没有接口, 没有引用, 你可以写很多套组件的交互逻辑, 你可以随意更改某个组合的逻辑, 却不用担心彼此之间的冲突耦合问题, 而组件本身里的代码, 除非改动太彻底, 否则都不需要动. 逻辑你就放心大胆的写, 就算不用, 放那也没事, 不行就ctrl a全选+注释, 改个名丢olds里, 假如哪天又需要了, 再注释回来, 因为都是连贯又独立的一套代码, 复用也简单.

###### 缺点

因为要用到底层的高效率组件判存, 所以和框架本身绑定比较深, 无法单独拿出来使用.

委托用的有点多, 确实委托算是c#为数不多容易造成内存泄露的点, 不过只要注意注销, 就不会出现这种事情, 所以组合器自带委托注销检测, 你只要注册了, 他就会检测你是不是也正确的注销了, 所以不必担心内存泄露的问题.

###### 备注

你可以用他实现类似依赖注入的效果, 但不建议你这么做, 因为那不符合组合器的设计理念, 组合器最大的作用是把组件交互逻辑给抽离出来了, 你用依赖注入, 又把逻辑放回去了. 当然对于某些天生就是一对的组件, 我们依然可以让他们直接交互, 这种情况往往组合器里只需要很少很少的代码, 可以这么说, 两个组件交互越顺滑, 组合器里的代码就越少, 所以在这个角度上, 组合器也有适配器的作用. 另外组合器是针对组件的, 而不是类, 所以依赖注入放到这里还是差点意思.

##### 影子函数系统(ShadowFunction)(推荐)

简单说, 在数据程序集里写一个源函数, 然后在另一个逻辑程序集里, 写一个一模一样的影子函数, 这两个函数就连通了, 当你调用源函数的时候, 他会执行到影子函数中去.

 支持async, 支持泛型类, 支持显示接口. 用起来更方便. 速度相比事件系统更快(因为是预先计算好了hashcode key, 所以整个过程只有一次强转). 能快速的定位源函数, 方便查看逻辑. 影子函数连接失败时, 会报错, 提升了安全性. 且该模块不强依赖于框架本身.

意义: 以一种更符合我们直觉的形式, 来实现数据与逻辑的分离, 如果你是要做热重载的话, 那相比传统方案, 没理由不用这个系统.

缺点: 虽然也支持类似广播的功能, 但不如传统事件系统灵活. 这主要与影子系统的设计理念有关, 他就是为了做热重载的, "广播功能"本就不该存在.

##### 优先级系统(Prioritizer)(非常推荐)

很久之前写的模块, 所以也维护很久了, 非常好用. 

意义: 主要用于制作非常复杂的技能、状态、动作系统. 技能前摇后摇, 点地板取消平A后摇, LOL吸血鬼W时可以放火箭腰带, 却不能放闪现, 石头人大可以放闪现却不能放火箭腰带, 武器大师摇花手时也可以正常释放其他技能, 吸血鬼放W时却不能放其他技能, 但如果是处于E技能释放状态, 则不会取消E技能, 净化能解引燃, 却不能解蚂蚱的大, 水银能解蚂蚱大, 却不能解引燃, 等等等等这些复杂的逻辑判断, 归根结底都是对优先级的判断, 一般来说, 游戏逻辑中的战斗系统复杂就复杂在各种状态的相互判断, 但有了这个系统, 一切都那么简单, 只需要在配置里改改参数, 就能实现各种复杂的逻辑判断.

系统里带了两个local time scale, 动作游戏中减速帧, 也可以很简单的实现.

针对其原理, 你甚至可以在UI逻辑上使用他, 比如打开了某个UI, 就需要关闭某些UI, 一般, 我们可能会把UI分组, 或者分流程, 但总归可能出现一个不安分的UI, 跟你唱反调, 他们组都关闭的时候, 他偏偏需要留下来, 或者如果有更复杂的上下层关系, 那你也可以使用优先级系统去处理他.

缺点: 没什么缺点, 就是好用.

##### 流水线系统(ProcedureLine)(推荐)

流水线系统(ProcedureLine), 该系统相当于Event系统的变种, 增加了热插拔功能, 本身并不复杂, 但带来的效果确实非常实用, 流水线有三个关键字, handle、item、worker. item代表了这条流水线是做什么的, handle是这条流水线上具体要做哪些事, worker则是决定了某个handle是否工作.

意义: 比如现在有条伤害逻辑, 固定的流程有, 计算人物属性 -> 计算对方属性 -> 交给伤害仲裁庭计算伤害 -> 执行掉血 -> 显示掉血信息, 但现在我加了一个增加伤害的BUFF, 这个BUFF可以在伤害时, 附加10%的攻击力, 那我就给他做一个worker + handle, 并把他的顺序排在计算人物属性与计算对方属性的中间, 当我获得这个BUFF的时候, 就把这个worker添加到流水线中, 这样再伤害时, 就会把人物攻击力增加10%再去仲裁庭, 同理, 如果有多种增加伤害的BUFF, 你也可以给他们排个序, 先增加谁, 再增加谁, 定好后, 就不用管了.

缺点: 写起来不友好, 要创建的东西多, 属于先受苦再享受的类型, 所以专门给他做了个代码生成Editor

### 模块

###### 行为树系统

把游戏逻辑用行为树的方式去实现, 然后交给config去配置, 可以快速的实现一个原型, 比如技能, 状态, 等.

###### 有形体系统

在Combin基础上实现的Bodied系统, 定义了有形体(Bodied)和无形体(Unbodied)的概念, 其实无论是游戏制作中, 还是其他地方, 任何组件都可以分成有形体和无形体, 简单说, 有形体定义了这个实体是什么, 无形体则给他提供能力. 当你把一个组件定义成有形体的时候, 那意为着他就可以代表他挂载的实体, 这也代表一个实体只能有一个有形体, 如此, 在父子关系中, 实际上是一个个的有形体之间的父子关系, 而不是实体之间的.

意义: 他就是帮我们让所属关系更清晰的, 本身并不复杂.

缺点: 存在感不如其他的模块强, 和框架绑定同样颇深. 不想用, 可以无视他.

###### 控制器系统

方便用户定义自己的控制指令, 并与Input的输入形成映射关系, 方便做改键系统, 手柄与键盘无缝切换等功能. 依赖于unity的InputSystem包.

系统分为两层, InputContorller, 和Control, 前者是在view层面, 而后者是逻辑层面, 用户输入的信息, 会转换为我们游戏内的ControlCode, 这个过程是必须的.

###### 数值系统

人物属性, 装备数值, 等需要用到数值的地方, 分为Numeric和Node两块, Node相当于是你装备的属性, Numeric相当于你的属性栏, 穿上装备时, 就把Node的数值加到Numeric重新计算出新的最终属性, 并且可以查找属性的来源, 提供了多少属性, 自己的源属性等功能.

###### HTask

单线程的Task, 本想直接用强大的UniTask, 但奈何他和Unity高度绑定, 所以实现了一个轻量版的, Task这个系统的核心功能其实就那些, 一般来说够用了, 如果有额外需求, 可以自行拓展.

支持多线程异步, 利用了线程池, 所以避免了线程的开启结束带来的损耗. 但不建议把长久的逻辑写在里面, 建议把一些高耗时的计算放到多线程去执行. 对于客户端来说, 完全的够用, 不要盲目的追求多线程.

模块中自带了一个TaskLine, 可以让多线程以非并发的形式执行, 避免的多线程的访问冲突问题, 根据需要选择性使用.

针对需要持久运行的逻辑, 后续可能会专门搞个多线程模块.

###### 协程系统(Coroutine)

可以脱离unity使用的一个协程, 最大的特点是支持子协程的嵌套, 并自动管理子协程生命周期. 比如你可以在一条逻辑链中, 直接yield return 一个用于监听用户确认的协程, 当前协程会自动开启这段子协程, 并等待用户按了确认后, 逻辑再继续往下执行, 逻辑链很优雅. 但说实话, 有了await\async后, 我已经很少使用协程了. 上面的情况交给await也能实现, 但确实有些时候, 协程更适合, 比如需要灵活管理生命周期的时候, 或是处理一个不要求代码连贯性的独立逻辑的时候, 更多的是在处理游戏逻辑的时候, 用他, 并且你可以清楚的从inspector中查看当前有哪些协程在运行.

###### 流程系统(Procedure)(注意这个和前面的ProcedureLine没什么关系, 只是名字比较像)

状态机FSM, 借鉴了GF框架中的Procedure系统, 当初第一次接触的时候, 对这个印象很深, 所以总是会带着它, 它最大的好处就是让你更清晰的查看你游戏运行的逻辑链, 适合客户端使用, 服务器别用, 浪费资源

###### 物理系统

写了一小部分, 可以检测碰撞, 检测射线, 但并不能作为解决方案使用, 但有兴趣的伙伴可以参考学习, 写了很多注释. 框架中确实有一些类似测试的代码, 一方面是作为我的笔记, 方便我需要时温习, 另一方面也是为了给伙伴们参考, 可能会不定时是删除这些笔记.

###### 选择器(Selector)

一个典型的过滤器模式, 以三个节点来过滤出想要的东西, 首先是搜索(Searcher) -> 过滤(Filter) -> 选择(Select).

例如搜索5m范围内目标 -> 过滤出所有活着的敌人 -> 选择最近的2个敌人, 可以自定义每个节点, 链式调用, 可以只过滤, 也可以只选择, 方便灵活, 针对频繁使用的过滤, 也可以写个专门的方法, 方便以后一步调用.

###### UI系统

一套简单的UI管理系统, 真就非常简单, 我不是太喜欢写UI

###### 事件系统(EventSystem)

框架标配

###### 网络模块

持续开发中...
Tcp联网已经搞的差不多了, 可以用了, 本身也支持拓展, 解析器、断线重连、活跃检测都可以自定义, 下一步先搞个小演示, 然后分布式和Kcp, 再就是物理系统和网格导航寻路.
现在只能在客户端跑server, 虽然已经把server独立出一个解决方案了, 但还没整理他.
为了保证低延迟, 我没有使用异步的方式去处理消息, 避免了那可能的一帧16ms的延迟, 同时借助PackageBuffer、IOCPPackageReceiver、IOCPPackageSender, 让数据的处理始终在一块内存上, 最大程度的减少数据拷贝的问题, 将3次拷贝, 降到1次(这1次发生在网卡那里, 避免不了), 因为收发数据是个非常高频的操作, 所以对其进行极致的优化, 就显得很有必要.

### 插件

Luban配置文件插件

HybridCLR热更插件

YooAsset资源管理插件

MemoryPack序列化库

Protobuf-net序列化库

InputSystem(unity的插件)

FMath(一套符合unity左右手的顶点数学库)

ZString(0GC字符串库)

### 安装教程

1.  下载完完整项目

#### 使用说明

1、直接打开


#### 参与贡献

dcze；

#### 特技

