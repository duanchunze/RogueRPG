# RogueRPG

### 介绍
这是一个使用Hsenl框架实现的demo

### 框架介绍
1、Hsenl框架是一款高性能的框架, 0GC, 核心底层使用了Bitlist, 让组件的判存, 获取, 非常快, 且支持多态. 有丰富的API, 满足需求.
2、框架不依赖于unity, 即便脱离unity, 核心功能以及大多数功能依然可以正常使用, 方便在服务端上使用框架.
3、支持对象的Instantiate(), 就像unity实例化预制体那样.
4、使用的MemoryPack序列化库, 速度秒杀市面上一众序列化方案, 甚至比unity原生的速度更快.
5、有丰富的系统事件, 且执行顺序是根据unity的规则来的, 所以记住一套规则就行了, 没有额外的没必要的学习成本.
6、工具模块丰富, 例如对象池、序列化库、时间系统、数据结构、Helper等常用的模块都有, 满足日常开发需求

### 特色模块

##### 1、组合器系统(Combin)

可以让完全的实现解耦合, 从此组件与组件之间不再需要相互引用就可以交互, 从此让项目彻底告别耦合引用, 让每个组件都干净、清爽. 而每个组合器, 也都是一个独立的小模块, 相互之间不影响, 可以随时注释掉, 修改, 都非常方便, 再也不用担心代码耦合带来的拓展难题.

##### 2、有形体系统(Bodied)

在Combin基础上实现的Bodied系统, 定义了什么是有形体(Bodied)和无形体(Unbodied), 从此所有的东西在所属逻辑上都变的非常清晰, 不会再出现混乱的情况. 不单单是在游戏制作中, 任何项目都可以遵循这个规则, 让逻辑更清晰. 如果你恰好要做一个类似MC那种复杂的逻辑, 那上面这两个系统将是不二选择.

##### 3、影子函数系统(ShadowFunction)

通过SourceGenerator技术实现, 你可以把他理解成一种extern函数, 从此你可以把任意函数体放到其他域去实现, 是做热重载的不二选择, 结构简单, 使用起来简单, 方便, 且速度比传统的事件系统更快, 支持async, 支持泛型类, 支持显示接口..., 同时也不强依赖于框架, 可以扣出去拿到别到项目使用, 事实上, 该框架中的大部分模块都不是强依赖与框架.

##### 4、优先级系统(Prioritizer)

可以实现用于制作非常复杂的技能、状态、动作系统. 技能前摇后摇, 点地板取消平A后摇, LOL吸血鬼W时可以放火箭腰带, 却不能放闪现, 石头人大可以放闪现却不能放火箭腰带, 武器大师摇花手时也可以正常释放其他技能, 吸血鬼放W时却不能放其他技能, 但如果是处于E技能释放状态, 则不会取消E技能, 净化能解引燃, 却不能解蚂蚱的大, 水银能解蚂蚱大, 却不能解引燃, 等等等等这些复杂的逻辑判断, 归根结底都是对优先级的判断, 一般来说, 游戏逻辑中的战斗系统复杂就复杂在各种状态的相互判断, 但有了这个系统, 一切都那么简单, 只需要在配置里改改数字, 就能实现各种复杂的逻辑判断.

##### 5、流水线系统(ProcedureLine)

流水线系统(ProcedureLine), 该系统相当于Event系统的变种, 增加了热插拔功能, 但带来的效果确实非常实用, 比如我们在造成伤害时, 有一条逻辑流程, 先获取自己的属性, 计算伤害, 计算对方防御, 计算掉血, 执行掉血, 显示掉血, 但如果情况更复杂后, 各种税前伤害, 税后伤害, 按初始力量增加伤害, 按装备属性增加伤害, 各种BUFF对伤害的影响, 我加了一个增加伤害的BUFF, 这个增加伤害是在计算属性的时候增加, 还是造成伤害后增加, 如果也有另一个增加伤害的BUFF, 这两个BUFF的先后顺序怎样的, 这些复杂的东西, 让一个简单的伤害行为在实际过程中却变的情况十分复杂, 但有了流水线系统, 我们只需要把所有的处理逻辑做成worker, 然后给他们定好顺序关系, 然后就不用问了. 而worker又相当于是一个个独立的小模块, 不用就不存在, 所以修改也十分简单.

### 模块

###### 1、行为树系统

根据知名的行为树插件实现的一个版本, 并在此基础上, 实现了AI行为树、剧本行为树、时间线行为树、极大的增加了代码的复用

###### 2、控制器系统

方便用户定义自己的控制指令, 并与Input的输入形成映射关系, 方便做改键系统, 手柄与键盘无缝切换等功能.

###### 3、NavMeshAgent

目前使用的就是unity的原生网格导航, 以后研究研究用第三方实现

###### 4、数值系统

根据ET的数值系统改的, 功能是差不多的

###### 5、物理系统

目前使用的就是unity的原生物理系统, 以后研究研究用第三方实现

###### 6、任务线(TaskLine)

把混乱的调用线, 整理成规范的调用线, 目前需要用的地方比较少

###### 7、协程系统(Coroutine)

可以脱离unity使用的一个协程, 最大的特点是支持子协程的嵌套, 且自动管理生命周期

###### 8、流程系统(Procedure)(注意这个和前面的ProcedureLine没什么关系, 只是名字比较像)

状态机FSM, 借鉴了GF框架中的Procedure系统

###### 9、任务锁(TaskLock)

引用的ET框架里的协程锁

###### 10、UI系统

一套简单的UI管理系统

###### 11、事件系统(EventSystem)

借鉴ET框架中的Event系统

###### 12、对象池、单例、时间、计时器等基础模块

### 插件

Luban配置文件插件

HybridCLR热更插件

YooAsset资源管理插件

MemoryPack序列化库

Protobuf-net序列化库

InputSystem(unity的插件)

FMath(一套符合unity左右手的顶点数学库)

ZString(0GC字符串库)

### 安装教程

1.  下载完完整项目

#### 使用说明

1、直接打开


#### 参与贡献

dcze；

#### 特技

